HAL
    - STCube HAL - new, Standard Peripheral Library - old
        - STCube HAL - improvements, simplifies porting code between sub-families.
    - To abstract away from GPIO memory locations, we use "handlers", which are
    "structs", whose references are used to point to real peripheral addresses.

6. GPIO management
    - Default reset status of pin - Input Floating Mode.
    - MODERy - Port x configuration bits (y = 0..15). Configures the I/O mode:
        - 00: input mode (reset state)
        - 01: General purpose output mode
        - 10: Alternate function mode.
        - 11: Analog mode.
    - ODR - Output data register.
        - Example: to "pull" pin high, "set" the corresponding bit of the ODR.
    - IDR - Input data register.
    - Peripherals that use MCU pins need to have these pins configured always.
    - Output i/o port
        - GPIO_MODE_OUTPUT_OD (open drain): 0 in ODR activates N-MOS, 1 leaves the port in Hi-Z
        - GPIO_MODE_OUTPUT_PP (push-pull): 0 in ODR activates N-MOS, 1 activates P-MOS
    - HAL_GPIO_ReadPin, HAL_GPIO_ReadPin, HAL_GPIO_TogglePin - used for driving pins.
      HAL_GPIO_LockPin - lock the configuration of the pin, until a reset occurs.
    - HAL_GPIO_Deinit - used when we no longer need a peripheral, or to avoid waste of power
      when the CPU goes into sleep mode.
    - Unless otherwise required, leave the deafult GPIO pin frequency to low.
    - bit-banding reduces switching frequency.

7. Interrupt management.
    Definition: async event, causes stopping the execution of the current code
    on a priority basis. Specifics:
        - Lower priority interrupts are suspended also.
        - Hardware save current context and knows how to continue after interrupt. 
        - Used by preemptive schedulers in RTOS.
        - Can originate by both software(exceptions) and hardware(IRQs).
    - NVIC - Nested Vectored Interrupt Controller.
        - EXTII - External Interrupt/Event Controller - responsible for
          interconnection between the external I/O signals and the NVIC controller.
        - system exceptions are also handled by NVIC.
    - vector table - maps interrupts to function addresses. Usually resides in
      0x0 for all Cortex-M processors, however in flash it resides in 0x0800 0000
      address, which is aliased to 0x0 when the CPU boots up.
    - ISR - code that survices the interrupt.
    - Types of exceptions (interrupts are also exceptions):
        - Reset (CPU is reset, handler is real entry point of firmware).
          Contains code to set up environment, stack pointer, etc.
          Cannot be masked.
        - NMI - critical/non-defferable activities. Linked to CSS.
            - CSS - Clock security system. Self-diagnostic peripheral that
              detects the failure of HSE.
          Cannot be masked.
        - Hard Fault - generic fault exception - software interrupts. When other
          "Fault" interrupts are disabled it acts like a generic handler for all.
        - Memory management fault - accessed when invalid memory is attempted to
          be accessed or violation rule.
        - Bus Fault - AHB interface receives an error response from a bus slave.
        - Usage Fault - program error (illeg- [X] Example scenario for GPIO_MODE_OUTPUT_OD

- [X] Do we lock pins using HAL_GPIO_LockPin?

- [X] Hard fault is always "automatically" raised? Potential issue with interrupts
      that are not handled and an unexpected fault is handled in a generic way?

- [X] Always pull-down with GPIO that generates interrupts? Is it related to the
"rising" or "falling" edge of the interrupt?

- [X] All pins between the two boundaries are mapped to the same EXTII line?
     (page 200)

- [X] best way to test protocols and peripherals? (use arduino as a second
        device?)
al instructions, etc)
        - SVCCall - Supervisor Call instruction is called. RTOS uses it to
          execute instructions in privilledged mode. (sys call)
        - Debug monitor - software debug event occurs, while core in Monitor
          Debug-mode. Also exception for debug events like breakpoints and
          watchpoints.
        - PendSV - like SVCCall, but can be delayed. Allows RTOS to complete
          tasks with higher priority.
        - SysTick - usually related to RTOS, HAL uses it to perform timing activities.
          HAL assumes that the SysTick timer is configured to perform interrupt
          every 1 ms.
        - IRQ handling
          - M0/M0+ cores - 32 external interrupts.
          - M3/M4/M7 - up to 240 interrupts.
        - HAL_NVIC_EnableIRQ - enable interrupt, based on interrupt type.
                               there is equivalent function for disable irq.
        - peripherals must be configured to work in interrupt mode to generate
          the associated interrupt. HAL functions can be used to configure the
          peripheral in interrupt mode. Example: HAL_USART_Trasmit_IT().
    - External interrupts - EXTII lines are connected to GPIO. Example F4:
          - Pins 5 - EXTI0, EXTI0_IRQ
          - Pins 10 - EXTI10, EXTI15_10_IRQ (shared)
          - Pins 10 - EXTI15, EXTI15_10_IRQ (shared)
            When the IRQ is shared, we need to discriminate which EXTII line
            generated the interrupt
          - There is a way to use CubeMX to init a GPIO as IT and call HAL to
            handle the discrimination between different interrupt sources.
    - Interrupt lifecycle:
          - interrupt can be disabled / enabled.
          - either be pending or not pending (waiting for a request to be served)
            An interrupt can be fired again while it is currently being served.
            In this scenario the pending bit can also be cancelled.
            We were using the __HAL_GPIO_EXTI_CLEAR_IT(), because the EXTI Line
            IRQ is being held high for a longer period of time.
          - either being in active or inactive state (currently being served)
            An interrupt is in an inactive state if it is currently being
            suspended because an interrupt with higher priority is being served.
          - it is possible to programatically fire an interrupt from inside the
            ISR of another interrupt. Also you can clear other pending interrupts.
    - Interrupt priority
          - IPR register - control priority of interrupt.
          - interrupt preemption - execution of lower priority interrupts is
            resumed if no higher priority interrupts are pending.
          - for M0 priority is static - priority cannot be changed until the IRQ
            is disabled.
          - Priorities can be subdivided in multiple ways in Cortex M3/4/7
            - AIRCR - subgroup of System Control Block register, defines how IPR
              bits are logically subdivided.
    - Interrupt re-entrace. You can rearrange code so that interrupts are just
      triggering boolean global variables.
    - interrupt masking - when you want to temporary prioritize tasks.
          - "masked" interrupts mean that the pending bit is being set, but the
            interrupt is not serviced.
          - CPSID i - disables all interrupts by setting PRIMASK bit to 1.
            __disable_irq() in CMSIS / __set_PRIMASK(x)
          - CPSIE i - enable all interrupts by setting PRIMASK bit to 0.
            Interrupts start to get serviced
            __enable_irq() in CMSIS / __set_PRIMASK(x)
          - CPSID f - disables all exceptions by setting FAULTMASK bit to 1. (no NMI)
            __set_FAULTMASK(x)
          - CPSIE f - enables all excepetions by setting FAULTMASK bit to 0.
            __set_FAULTMASK(x)
          - Cortex M3/4/7 can mask based on priority in the BASEPRI register.
            (both exceptions and interrupts)

8. UART/USART
    - Description:
        Communication peripheral (interface + protocol), At least two of those
        in in almost all STM32 MCUs.
        Transfers parallel data into a stream of series data between a
        transmitter and a receiver.
        - Operating modes: 
            - polling - HAL_UART_Transmit, HAL_UART_Receive
                - huart - pointer to handle,
                - pData - pointer to an array.
                - Timeout - maximum time expressed in miliseconds
            - interrupt
            - DMA
        - sync - shared clock
        - async - shared baud rate
        - voltage levels are determined by the MCU I/O (Vdd)
    - handle structure:
        - instance - pointer to descriptor
        - init - struct to configure the uart interface
            - baud rate - for async, measured in bps
            - word length - number of data bits transmitted or received in
              frame. (8 bit or 9 bit data, does not contain overhead bits)
            - stop bits - number of stop bits transmitted (1 or 2 bits)
            - parity - indicates the parity mode (none, even, odd). Not
              frequently used, requires both sender and receiver to implement
              error handlers. When parity fails, specific interrupt is generated
              for all STM32 MCUs
            - mode - Tx(transmit only)/Rx(Receive only)/Tx_Rx(both) modes
            - HwFlowCtl - RS 232 Hardware Flow Control mode is enabled or disabled.
            - OverSampling - sampling signal with significantly higher frequency.
              (16 or 8 sambles for each bit)
        - advanced init - advanced features (auto baud rate, tx/rw swap, etc.)
        - pTxBuffPtr/pRxBuffPtr - buffers to be transmitted.
        - TxXferBytes/RxXferBytes - size of buffers.
        - TxXferCount/RxXferCount - used internally by HAL.
        - Lock - used internally by HAL to stop concurrent access to UART
    - related interrupts:
        - Transmit Data Register Empty
        - Clear to send.
        - Transmission complete
        - Rereceived Data Ready to be Read
        - Overrun error detected
        - Idle Line detected.
        - Parity Error.
        - Break Flag.
        - Noise Flag, Overrun error or Framing
        - Error in multi buffer communication.

9. DMA management
    - transfer data from internal SRAM / Flash to peripheral register has overhead.
      (requires extra cpu cycles, can cause loss of async events)
    - DMA controller - dedicated HW unit, allows data transfer between
      peripherals and internal memories without mediation by the Cortex-M core.
    - STM32 MCU usually have more than one DMA controller.
    - both CPU and DMA controller are "masters" - only they can start a
      transaction on a bus. Access to the bus needs to be regulated so that they
      don't access the same peripheral at the same time.
    - Bus Matrix - manages access arbitration between Cortex-M and the DMA1 controller.
      Arbitration uses Round Robin to rule the access to the bus.
        - two masters (CPU, DMA)
        - four slaves (flash, SRAM, AHB1 with AHB to APB bridge, AHB2)
    - System bus connects "Bus Matrix" to Cortex-M core.
    - DMA bus connects AHB master interface of DMA to the Bus Matrix.
    - AHB, AHB1, AHB2, APB - hardware components, can be clocked by different
      sources to achieve different speeds. Access to slower peripherals can
      introduce bottlenecks in application
      They are defined by AMBA (Arm Advanced Microcontroller Bus Architecture)
    - DMA is connected to the AHB1 bus as part of the interrupt mechanism.
      (peripherals are slaves, they cannot access the bus independently)
    - Parts of the DMA controller:
        - peripheral master port (connected to AHB bus). Interfacing slave peripherals, sometimes able
          to access memory controller also for memory-to-memory DMA.
        - memory master port (connected to AHB bus). Interfaces memory controller.
        - slave port, connected to the AHB bus, used to program the DMA from the
          CPU
        - has number of independent programmable channels (request sources),
          each one connected to a peripheral line.
        - allows to assign priorities to channels, in order to arbitrate the
        access to the memory
        - allows data to flow in both directions (from memory to peripheral and
          from peripheral to memory.
    - Phases of DMA:
        - sample and arbitration phase.
        - address computation phase.
        - bus access phase.
        - acknowledgement phase. (signal that the transfer has been done)
        NOTE: All phases take a single cycle, except for the bus access phase.
    - DMA_HandleTypeDef:
        - instance - pointer to DMA/Channel pair that we are going to use.
        - init - used to configure the DMA channel.
            - direction - peripheral to memory / memory to peripheral / memory
              to memory
            - periphinc - auto increment the peripheral port register.
            - meminc - auto increment the address in memory.
            - periphdataalighnment - transfer data size of peripheral. (byte,
              word, half-word)
            - memdataalignment - ...
            - mode - circular(starts again from the beginning after finished) or normal(stops after transfer is done) 
              circular mode is also called "continous mode" and is only way to
              achieve high speed with some periperals (SPI devices)
            - priority -  Low / Medium / High / Very-High
            - FIFO mode - each stream has 4x32bit FIFO. Used to store tmp data
              coming from source, before transmitting to the destination.
                - reduces SRAM access, gives other masters time to access Bus
                  Matrix without additional concurrency.
                - allows software to do burst transactions, which optimizes
                  transfer bandwidth
                - if the mode is enabled, data packing/unpacking/Burst Mode can
                  be used.
                - FIFO is automatically emptied at a certain treshold level.
                  1/4, 1/2, 3/4 or full size.
            - MemBurst - avoids round robin scheduling policy rules to access the DMA
              stream before it can access sequence of bytes through the AHB bus.
              Skips the steps required to transmit data in separate transactions.
                - single
                - inc4
                - inc8
                - inc16

        - parent - HAL uses it to keep track of peripheral handlers associated.
          Example: UART_HandleTypeDef for UART in DMA mode.
        - callbacks - automatically called by HAL_DMA_IRQHandler when interrupt is fired:
            - XferCpltCallback - completed callback
            - XferCpltCallback - half-completed callback
            - XferErrorCallback -  error occured.
    - memory-to-memory DMA - can be used to transfer large arrays from FLASH to
      SRAM.

10. Clock tree
    - reducing the clock frequencies (or disable) of some parts of the MCU reduces overall power consumption.
    - clock sources
        - internal RC oscillator. (High Speed Internal - HSI)
        - external dedicated crystal oscillator. (High Speed External - HSE)
            - higher precision, operating temperature matters. (can mess with time precision)
            - some high speed peripherals can be clocked only by dedicated external clocks, running at the given frequency.
        - internal low speed oscillator (LSI), drives:
            - RTC - real-time clock
            - IWDT - Independent Watchdog Peripheral 
        - external low speed oscillator (LSE)
    - clock tree - complex distribution network resposible for propagation of the clock signal inside the MCU.
                   Frequency of the high speed oscillator does not establish the actual frequency of the MCU or the peripherals
                   It is possible to increase/decrease the frequency at needs using:
                        - PLL - phase-locked loops
                        - prescales
                        - SW - System Clock Switch / System Clock Multiplexer.
                    Purpose of this is to either increase performance or decrease power consumption.
        - RCC - reset and clock control, clock tree configuration is done through the dedicated peripheral.
                Steps usually done by the unit:
                    - high speed oscillator source is selected.
                    - if we need higher SYSCLK speeds, configure the main PLL.
                    - SW is concifugred, choosing the right source(HSE, HSI or PLLCLK)
                    - select prescaler for bus AHB, APB1 and APB2 to reach the desired frequency of the High-speed clock(HCLK)
                Improper configurations can damage the MCU!


Misc:
    - BOM - bill of material.
    - RCC - reset and clock controller.
    - System bus - connects system bus of core to bus matrix
    - DMA bus - connects AHB interface of DMA to the BusMatrix
    - Bus matrix - two masters(CPU, DMA) and four slaves (flash, sram, AHB1, AHB2)
    - Round-robin - simple scheduling algorithm, equal time slices without
    - priority structured in a ring buffer.
    - "absolute file" - file that we upload to flash.
    - debouncing - process of minimizing the impact of bouncing, produced by
      unstable forces (mechanical switch). Generally we deal with it by
      measuring how much time has elapsed from the first variation of the input
      state.
    - escape characters:
        - \033[0;0H - place cursor at the top left of the available console.
        - \033[2J - clear the screen
    - Cortex M0/0+ - Von Neumann architecture (one bus to access instr and data)
    - Other Cortex M cores - Harvard architecture. Have two busses to access
        instructions and data:
        - I-Code - instruction bus.
        - D-Code - data bus.
    - instead of "volatile" we use "__IO/__I/__O" macros
    - global data is stored in SRAM.
      static "local" variables are also allocated in .data region
      "const" instructs linked to put the data in Flash instead.
    - stm32XXxx_hal_ppp_ex.c - for particular MCU we can have specific
    "extension" files. (ppp - peripheral)
    - power consumption is about liniar with clock frequency. Higher frequency leads to bigger power comsumption.
