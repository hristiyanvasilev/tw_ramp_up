- Definition - real-time kernel, on which applications can built to meet hard real-time requirements.
               allows applications to be organized as separate threads of execution.
               (NOTE: cannot do multiple processes at the same time)
- benefits
    - abstracting away timing information.
    - maintainability/extensibility
    - modularity
    - team development
    - easier testing
    - code reuse
    - improved efficiency
    - idle time - task created when the kernel is started.
        - can be used to measure spare capacity
        - perform background checks
        - place processor into low-power mode
    - power management
        - allows processor to be spend more time in low power mode (tick-less mode)
        - flexible interrupt handlers - can be kept very short by defferring processing to either
                                        application task or deamon task.
- task - thread of execution.
    - xTaskCreate() - createa new task
        - pvTaskCode - ptr to function that implements the code.
        - pcName - descriptive name of the task.
        - usStackDepth - number of words that the stack can hold.
            - configMINIMAL_STACK_SIZE - idle task size.
        - pvParameter - parameter that is being passed to the task.
        - uxPriority - priority of task. Higher number, indicates higher priority.
        - pxCreatedTask - handle to task. This handle can be used to pass to API calls.
                          Example: change priority or delete task.
        - vTaskDelete - delete a task. Idle task is responsible for freeing memory.
        NOTE: you can create tasks from other tasks.
    - blocked state - waiting for an event: temporal / synchronization
    - suspended state - task is not available to the scheduler. (special function calls)
    - ready state - ready to be scheduled.
    - idle task
        - cannot be blocked or suspended.
        - responsible for cleanup resources, meaning that hook cannot be computationally expensive.
          (thread needs to do other stuff)
        - configIDLE_SHOULD_YIELD - indicates either the idle task should yied execution on each loop
                                    or it should wait to be preempted by higher priority threads.
    - priority
        - vTaskPrioritySet - change priority of task.
        - uxTaskPriorityGet - query the priority of task.
    - time-slicing - scheduler gives equal time for tasks that have equal priority.
                     time slice is equal to time between two RTOS tick interrupts.
                     Running a scheduler without time-slicing is considered an advanced technique.
- scheduling algorithms - all are round robin, time might not be shared equally.
    - configUSE_PREEMPTION (usually set to 1)
        - cooperative scheduling (when set to 0), no preemption will occur onless task enters BLOCKED state or
          running task explicitly yields. (by calling taskYield())
    - configUSE_TIME_SLICING (usually set to 1)
    - configUSE_TICKLESS_IDLE (usually set to 0) - minimizes power consumption.
- queues - used for task-to-task, task-to-interrupt and interrupt-to-task communication mechanism.
    - FreeRTOS uses queue by copy.
    - any number of tasks or ISRs can read/write from a queue. (less common for multiple readers to exist)
    - blocking on queue reads - specify a 'block' time which the task will remain in blocked state if no data is available on queue.
                                Tasks are automatically unblocked once data is available to be read on the queue.
                                If tasks with same priority are blocking on the same read, the one that has been waiting the most will be ran.
    - blocking on writes - specify a 'block' time which the task will remain in blocked state if no space is available for a write.
                           If tasks with same priority are blocking on the same write, the one that has been waiting the most will be ran.
    - xQueueCreate - create a new queue.
        - uxQueueLength - maximum number of items that a queue can hold.
        - uxItemSize - size of each item
    - xQueueSendToBack and xQueueSendToFront - send data on the back or the front of the queue.
    - xQueueSendToFrontFromISR and xQueueSendToBackFromISR - equivalent functions for ISRs.
        - xTicksToWait - amount of time the task should remain in Blocked state.
    - uxQueueMessagesWaiting - get the number of messages in queue.
        - uxQueueMessagesWaitingFromISR - from ISRs
    - xQueueOverwrite - overwrite the data - should only be used when the queue has a size of 1.
    - xQueuePeek - read the element without removing it from the queue.
    - mainbox - queue with size of 1
- Deadlines
    - soft deadline - not meeting the deadline does not render the system to be useless.
                      Example: system might slow down, but does not stop
    - hard deadline - breaching the deadline will result in absolute system failure.
                      In the most simplistic case threads with higher priority for important tasks.
                      Example: airbag system has potential to do more harm than good if it fails
                               to deploy itself after failure to meet deadline.
- distribution
    - distributed as a single .zip file, containing all official FreeRTOS ports + demo applications.
    - critical common files - tasks.c/list.c (+queue.c usually)
    - FreeRTOS - FreeRTOS/Sources/portable/[compiler]/[architecture]
- init
    - prvSetupHardware() - any necessary hardware setup
    - vTaskStartScheduler() - start kernel
- data types
    - TickType_t - Holds tick count since kernel started, unsigned 16/32-bit type.
    - BaseType_t - most efficient type for architecture.
    Compiler requires that each variable needs to be qualified with either signed or unsigned.
- convention
    - variables
        - c - char
        - s - short
        - i - int
        - x - BaseType_t
        - u - unsinged
        - p - pointer
        Example: variable of type uint8_t will be prefixed with 'uc'
    - functions - defined both the return type and the file that they are defined in.
        - prv - private(scope) functions
        Example: vTaskPrioritySet() - returns 'void' and is defined in 'task.c'
    - macros
        - upper case, prefixed with lower case letters, indicating where they are defined.
    - spacing - one tab is always equal to four spaces.
- heap utility functions
    - xPortGetFreeHeapSize - get the size of heap left over.
    - xPortGetMinimumEverFreeHeapSize - indicate how close the app has ever been to running out of space.
    - pvPortMalloc - can be called directly from app code, also it is being used by kernel.
- software timer management
    - They do not require hardware support, and are not related to hardware timers or hardware counters. Purely implemented in the kernel.
    - FreeRTOS/Source/timers.c as part of your project.
    - configUSE_TIMERS to 1
    - period - time between the software timer being started,
               and the software timerâ€™s callback function executing.
    - type of timers:
        - one-shot timers
        - auto-reload timers
    - RTOS Daemon - all timer callback functions execute in the context of the same RTOS daemon
    - xTimerCreate - create a new timer.
    - xTimerStart - used to start a software timer.
    - xTimerStop - stop a software timer.
    - xTimerReset - reset a software timer.    
- Interrupt management
    - tasks vs ISR
        - task - software feature that is unrelated to the hardware on which FreeRTOS is running.
                Priority of task is assigned in software by the application writer.
                Tasks run only when no interrupt is no ISR currently running.
        - ISR - hw decides which ISR will run (so hw feature)
                Lowest priority ISR superseeds highest priority task.
                There is no way to pre-empt an ISR.
    - deferred interrupt processing - keep ISRs as short as possible.
        - even if tasks are high priority, they will only run if no interrupts are being serviced by the hardware
        - issues with interrupts waiting to be handled while ISRs are running on some platforms.
        - should guard against ISRs and tasks accessing variables, peripherals and meory buffers at the same time.
        - nesting interrupts increases complexity and reduces predictability.
        - binary semaphores can be used to synchronze the ISR with the task handler.
          (task takes, ISR gives back)
    - specifics
        - pxHigherPriorityTaskWoken - indicate if a context switch should be performed.
                                      optional parameter, can be NULL.
        - portYIELD_FROM_ISR and portEND_SWITCHING_ISR - interrupt safe versions of taskYIELD. One use is to make sure that the task handling interrupt request is the next to execute.
    - sempahores
        - xSemaphoreTake(FromISR) - decreases the sempahore counter
        - xSemaphoreGive(FromISR) - increases the sempahore counter
        - xSemaphoreCreateBinary - creates a binary semaphore.
    NOTE: if an ISR calls an OS API, it has no way to put the task in BLOCKED state,
          FreeRTOS solves the issue by providing additional API functions for ISRs.
Misc:
    - can be built with many different compilers.
