/*
 * tests.c
 *
 *  Created on: Jul 27, 2020
 *      Author: Hrist
 */

#include "main.h"

extern UART_HandleTypeDef huart2;

uint8_t initial_print = 1;

//contains one character that has been read by the UART
//needs to be a global variable
uint8_t byte_read_buffer = 0;
uint8_t should_receive = 0;

DMA_HandleTypeDef hdma_usart2_tx;
char msg[] = "Hello! This is an example of USART2 DMA with interrupts!";

//brief - toggle blinking external led connected to "PC3" by pressing "USER B1".
//        toggle occurs on button release.
static void toggle_external_led_blink(void)
{
	  uint8_t is_down = 0;
	  uint8_t should_blink = 0;
	  while (1)
	  {
		if (HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET)
		{
			is_down = 1;
		}

		if (is_down && HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_SET)
		{
			should_blink = !should_blink;
			is_down = 0;
		}

		if(should_blink)
		{
			HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_3);
			HAL_Delay(200);
		}
	  }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN)
{
	//handle just the interrupt for USER btn1
	if(GPIO_PIN_13 == GPIO_PIN)
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
}

//brief - interrupt handler for USER btn1 is pressed.
void EXTI4_15_IRQHandler(void)
{
	//clear the interrupt and toggle the pin
	//should be cleared only when if we not utilizing the HAL
	//__HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_13);

	//internally the interrupt flag is being cleared.
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
}

//brief - configure user button 1 to generate interrupt
//		  start blinking when the button is clicked
static void user_bt1_interrupt()
{
	GPIO_InitTypeDef GPIO_InitStruct;

	//remove the existing auto-generated configuration for the pin
	HAL_GPIO_DeInit(GPIOC, GPIO_PIN_13);

	//re-init the pin with the new configuration
	GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	//enable the interrupt line for the pin
	HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);

	while(1)
	{
		//do nothing
	}
}

uint8_t readUserInput(void) {
	char readBuf[1];
	char PROMPT[] = "Prompt!\r\n";

	HAL_UART_Transmit(&huart2, (uint8_t*)PROMPT, strlen(PROMPT), HAL_MAX_DELAY);
	HAL_UART_Receive(&huart2, (uint8_t*)readBuf, 1, HAL_MAX_DELAY);
	return atoi(readBuf);
}


void printWelcomeMessage(void) {
	char WELCOME_MSG[] = "Welcome!\r\n";
	char MAIN_MENU[] = "Main menu!\r\n";

	if(initial_print)
	{
		HAL_UART_Transmit(&huart2, (uint8_t*)"\033[0;0H", strlen("\033[0;0H"), HAL_MAX_DELAY);
		HAL_UART_Transmit(&huart2, (uint8_t*)"\033[2J", strlen("\033[2J"), HAL_MAX_DELAY);
		initial_print = 0;
	}
	HAL_UART_Transmit(&huart2, (uint8_t*)WELCOME_MSG, strlen(WELCOME_MSG), HAL_MAX_DELAY);
	HAL_UART_Transmit(&huart2, (uint8_t*)MAIN_MENU, strlen(MAIN_MENU), HAL_MAX_DELAY);
}

uint8_t processUserInput(uint8_t opt) {
	char msg[30];

	if(!opt || opt > 3)
		return 0;

	sprintf(msg, "%d", opt);
	HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

	switch(opt) {
		case 1:
			HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
			break;
		case 2:
			sprintf(msg, "USER BUTTON status: %s",
					HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET ? "PRESSED\r\n" : "RELEASED\r\n");
			HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
			break;
		case 3:
			return 2;
	};

	return 1;
}

static void uart_polling_example()
{
	uint8_t opt = 0;

	while(1)
	{
		printWelcomeMessage();

		opt = readUserInput();
		processUserInput(opt);
	}
}

//callback automatically called by the HAL when one byte is received
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
{
	asm("BKPT #0");

	//toggle the LED2
	HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
	//listen for the next byte
	should_receive = 1;
}

//callback automatically called by the HAL when one byte is received
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
{
	//echo back the byte through the UART
	HAL_UART_Transmit_IT(&huart2, &byte_read_buffer, sizeof(byte_read_buffer));
}

//Weak ISR for UART2 calls the generic HAL_UART_IRQHandler with the handle to the UART2
//NOTE: This IRQ Handler should not be here, it should be part of the corresponding strm32f0xx_it.c
//      It was added here beucase we are just testing stuff in this project.
void USART2_IRQHandler(void)
{
	HAL_UART_IRQHandler(&huart2);
}

//Practice UART interrupts. Excercises sending and receiving data through
//UART and handling the interrupts generated by data being send or received.
//1. receive a byte
//2. in the handler of the data received, send a byte
//3. in the handler of a byte send, turn on the LED2
static void uart_it_example()
{
	//enable UART interrupts
	HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(USART2_IRQn);

	//Receive one byte through the USART2
	should_receive = 1;
	while(1)
	{
		if(should_receive)
		{
			HAL_UART_Receive_IT(&huart2, &byte_read_buffer, sizeof(byte_read_buffer));
			should_receive = 0;
		}
	}
}

void DMA_Transfer_Complete(DMA_HandleTypeDef *hdma)
{
	if(hdma->Instance == DMA1_Channel4)
	{
		//Disable UART DMA mode
		huart2.Instance->CR3 &= ~USART_CR3_DMAT;
		//turn led on
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
	}
}

void DMA1_Channel4_5_IRQHandler()
{
	HAL_DMA_IRQHandler(&hdma_usart2_tx);
}

void uart_it_dma_example()
{
	//enable clock for DMA
	__HAL_RCC_DMA1_CLK_ENABLE();

	hdma_usart2_tx.Instance = DMA1_Channel4;
	hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
	hdma_usart2_tx.Init.Mode = DMA_NORMAL;
	hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
	hdma_usart2_tx.XferCpltCallback = DMA_Transfer_Complete;
	hdma_usart2_tx.XferAbortCallback = NULL;
	hdma_usart2_tx.XferErrorCallback = NULL;
	hdma_usart2_tx.XferHalfCpltCallback = NULL;

	hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
	hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;

	hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
	hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;

	HAL_DMA_Init(&hdma_usart2_tx);

	//enable interrupt
	HAL_NVIC_SetPriority(DMA1_Channel4_5_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel4_5_IRQn);

	HAL_DMA_Start_IT(&hdma_usart2_tx, (uint32_t)msg, (uint32_t)&huart2.Instance->TDR, strlen(msg));
	huart2.Instance->CR3 |= USART_CR3_DMAT;

	while(1);
}

//simple function that toggles led, used to practice very basic debugging.
void simple_toggle_led()
{
	while(1)
	{
		//asm("BKPT #0");

		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
		HAL_Delay(200);

		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
		HAL_Delay(200);

		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
		HAL_Delay(200);

		//testing what happens when we set more than 6 hw breakpoints
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
		HAL_Delay(200);
	}
}

int run_test_scenario()
{
	//simple_toggle_led();
	//toggle_external_led_blink();
	//user_bt1_interrupt();
	//uart_polling_example();
	uart_it_example();
	//uart_it_dma_example();
	//while(1);
	return 0;
}
